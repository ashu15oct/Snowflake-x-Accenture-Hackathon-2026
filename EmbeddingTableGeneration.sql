USE DATABASE RETAIL_DB;
USE SCHEMA ABT_BUY;

CREATE OR REPLACE VIEW abt_canonical AS
SELECT
    ID AS PRODUCT_ID,
    TRIM(
        LOWER(
            COALESCE(NAME, '') || ' ' || 
            COALESCE(DESCRIPTION, '')
        )
    ) AS CLEAN_TEXT,
    PRICE
FROM ABT;

CREATE OR REPLACE VIEW buy_canonical AS
SELECT
    ID AS PRODUCT_ID,
    TRIM(
        LOWER(
            COALESCE(NAME, '') || ' ' || 
            COALESCE(DESCRIPTION, '') || ' ' || 
            COALESCE(MANUFACTURER, '')
        )
    ) AS CLEAN_TEXT,
    PRICE
FROM BUY;

CREATE OR REPLACE TABLE abt_embeddings AS
SELECT
    PRODUCT_ID,
    CLEAN_TEXT,
    AI_EMBED('snowflake-arctic-embed-m', CLEAN_TEXT) AS EMBEDDING
FROM ABT_CANONICAL;

CREATE OR REPLACE TABLE buy_embeddings AS
SELECT
    PRODUCT_ID,
    CLEAN_TEXT,
    AI_EMBED('snowflake-arctic-embed-m', CLEAN_TEXT) AS EMBEDDING
FROM BUY_CANONICAL;

CREATE OR REPLACE TABLE SIMILARITY_SCORES AS
WITH similarity_scores_cte AS (
    SELECT
        a.PRODUCT_ID AS ABT_ID,
        b.PRODUCT_ID AS BUY_ID,
        VECTOR_COSINE_SIMILARITY(a.EMBEDDING, b.EMBEDDING) AS SIMILARITY
    FROM ABT_EMBEDDINGS a
    CROSS JOIN BUY_EMBEDDINGS b
)
SELECT
    ABT_ID,
    BUY_ID,
    SIMILARITY
FROM similarity_scores_cte
ORDER BY SIMILARITY DESC;

CREATE OR REPLACE TABLE PRODUCT_MATCHES AS
SELECT ABT_ID, BUY_ID, SIMILARITY
FROM (
    SELECT
        ABT_ID,
        BUY_ID,
        SIMILARITY,
        ROW_NUMBER() OVER (PARTITION BY ABT_ID ORDER BY SIMILARITY DESC) AS RN
    FROM SIMILARITY_SCORES
)
WHERE RN = 1 AND SIMILARITY >= 0.80;

SELECT
    COUNT(*) AS TOTAL_GROUND_TRUTH,
    SUM(CASE WHEN PM.BUY_ID IS NOT NULL THEN 1 ELSE 0 END) AS CORRECT_MATCHES
FROM ABT_BUY_PERFECTMAPPING GT
LEFT JOIN PRODUCT_MATCHES PM
    ON GT.IDABT = PM.ABT_ID
    AND GT.IDBUY = PM.BUY_ID;

SELECT
    PM.ABT_ID,
    PM.BUY_ID,
    A.PRICE AS ABT_PRICE,
    B.PRICE AS BUY_PRICE,
    CASE
        WHEN A.PRICE IS NULL OR B.PRICE IS NULL THEN NULL
        ELSE TRY_TO_DOUBLE(REGEXP_REPLACE(B.PRICE, '[$,]', '')) - TRY_TO_DOUBLE(REGEXP_REPLACE(A.PRICE, '[$,]', ''))
    END AS PRICE_DIFF
FROM PRODUCT_MATCHES PM
LEFT JOIN ABT_CANONICAL A ON PM.ABT_ID = A.PRODUCT_ID
LEFT JOIN BUY_CANONICAL B ON PM.BUY_ID = B.PRODUCT_ID;

CREATE OR REPLACE VIEW final_product_matches AS
SELECT
    ABT_ID,
    BUY_ID,
    SIMILARITY,
    'EMBEDDING_BASED' AS MATCH_STRATEGY,
    CASE
        WHEN SIMILARITY >= 0.90 THEN 'HIGH'
        WHEN SIMILARITY >= 0.85 THEN 'MEDIUM'
        ELSE 'LOW'
    END AS CONFIDENCE_BUCKET,
    SIMILARITY AS FINAL_CONFIDENCE
FROM PRODUCT_MATCHES
WHERE SIMILARITY >= 0.80;

CREATE OR REPLACE VIEW price_comparison AS
SELECT
    F.ABT_ID,
    F.BUY_ID,
    A.PRICE AS ABT_PRICE,
    B.PRICE AS BUY_PRICE,
    CASE
        WHEN A.PRICE IS NULL OR B.PRICE IS NULL THEN 'INSUFFICIENT DATA'
        WHEN TRY_TO_DOUBLE(REGEXP_REPLACE(A.PRICE, '[$,]', '')) > TRY_TO_DOUBLE(REGEXP_REPLACE(B.PRICE, '[$,]', '')) THEN 'ABT_OVERPRICED'
        WHEN TRY_TO_DOUBLE(REGEXP_REPLACE(A.PRICE, '[$,]', '')) < TRY_TO_DOUBLE(REGEXP_REPLACE(B.PRICE, '[$,]', '')) THEN 'BUY_OVERPRICED'
    END AS PRICING_STATUS
FROM FINAL_PRODUCT_MATCHES AS F
LEFT JOIN ABT A ON F.ABT_ID = A.ID
LEFT JOIN BUY B ON F.BUY_ID = B.ID;

CREATE OR REPLACE VIEW matching_metrics AS
SELECT
    COUNT(*) AS TOTAL_GROUND_TRUTH_PAIRS,
    COUNT(F.ABT_ID) AS CORRECTLY_MATCHED_PAIRS,
    ROUND(
        COUNT(F.ABT_ID) / COUNT(*) :: FLOAT,
        4
    ) AS PRECISION
FROM ABT_BUY_PERFECTMAPPING GT
LEFT JOIN FINAL_PRODUCT_MATCHES F
ON GT.IDABT = F.ABT_ID
AND GT.IDBUY = F.BUY_ID;

CREATE OR REPLACE TABLE match_config AS
SELECT 0.80::FLOAT AS similarity_threshold;